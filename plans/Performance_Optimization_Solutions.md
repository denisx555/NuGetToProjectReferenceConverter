# Анализ производительности и варианты решений

## Анализ лога (logs/app.log)

### Выявленные проблемы

#### 1. Многократный поиск в одних и тех же директориях

Метод `FindProjectFileInFileSystem.SearchDir` вызывается многократно для одних и тех же директорий:

| Директория | Кол-во файлов | Время на поиск | Количество вызовов |
|------------|---------------|----------------|-------------------|
| `analysis` | 1123 .csproj | 1.2-4.5 сек | ~20+ раз |
| `eam` | 191 .csproj | 0.3-0.8 сек | ~20+ раз |
| `Galaktika.EAM` | 30 .csproj | 0.04-0.2 сек | ~20+ раз |

**Пример из лога:**
```
Line 38: PERF: FindProjectFileInFileSystem.SearchDir(analysis) took 4472,04 ms
Line 79: PERF: FindProjectFileInFileSystem.SearchDir(analysis) took 2276,50 ms
Line 142: PERF: FindProjectFileInFileSystem.SearchDir(analysis) took 1234,39 ms
Line 201: PERF: FindProjectFileInFileSystem.SearchDir(analysis) took 1981,01 ms
```

#### 2. Отсутствие кэширования результатов поиска

Каждый раз при поиске проекта происходит полный скан директории с помощью `Directory.GetFiles()`, даже если эта директория уже сканировалась ранее.

#### 3. Медленная операция добавления проекта в папку

`AddProjectToReplacedProjectsFolder` занимает очень много времени:

| Проект | Общее время | Время поиска зависимостей | Время добавления в папку |
|--------|-------------|---------------------------|-------------------------|
| Xafari.Editors.Blazor | 130 сек | ~5 сек | ~25 сек |
| Xafari.Blazor | 50 сек | ~1.4 сек | ~26 сек |
| Xafari.ManagedOperations.Blazor | 103 сек | ~2.2 сек | ~79 сек |

#### 4. Рекурсивная обработка зависимостей

Каждый проект загружается через MSBuild, затем ищутся его зависимости, и для каждой зависимости снова вызывается поиск в файловой системе.

---

## Варианты решений

### Вариант 1: Кэширование списков файлов в директориях

**Описание:** Создать кэш, который хранит списки .csproj файлов для каждой директории.

**Преимущества:**
- Устраняет повторное сканирование директорий
- Простая реализация
- Значительное ускорение при поиске зависимостей

**Недостатки:**
- Требует дополнительной памяти
- Кэш нужно очищать при изменении файловой системы

**Ожидаемый эффект:** Сокращение времени поиска на 70-90%

**Реализация:**
```csharp
private static readonly Dictionary<string, string[]> _directoryCache = new();

private string[] GetProjectFilesFromDirectory(string directory)
{
    if (_directoryCache.ContainsKey(directory))
        return _directoryCache[directory];
    
    var files = Directory.GetFiles(directory, "*.csproj", SearchOption.AllDirectories);
    _directoryCache[directory] = files;
    return files;
}
```

---

### Вариант 2: Предварительное индексирование всех проектов

**Описание:** При запуске создать индекс всех проектов в файловой системе (имя проекта → путь к файлу).

**Преимущества:**
- Мгновенный поиск проектов по имени
- Однократное сканирование файловой системы
- Максимальная производительность при поиске

**Недостатки:**
- Требует времени на первоначальное индексирование
- Требует памяти для хранения индекса
- Нужно обновлять индекс при изменении файлов

**Ожидаемый эффект:** Поиск проектов за <1 мс вместо 1-5 сек

**Реализация:**
```csharp
private static Dictionary<string, string> _projectIndex;

private void BuildProjectIndex(string rootDirectory)
{
    _projectIndex = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
    var files = Directory.GetFiles(rootDirectory, "*.csproj", SearchOption.AllDirectories);
    
    foreach (var file in files)
    {
        var projectName = Path.GetFileNameWithoutExtension(file);
        _projectIndex[projectName] = file;
    }
}

private string FindProjectInIndex(string projectName)
{
    return _projectIndex.TryGetValue(projectName, out var path) ? path : null;
}
```

---

### Вариант 3: Оптимизация порядка поиска директорий

**Описание:** Изменить порядок поиска директорий, чтобы сначала проверять наиболее вероятные места.

**Преимущества:**
- Не требует дополнительной памяти
- Простая реализация
- Улучшает среднее время поиска

**Недостатки:**
- Не устраняет повторное сканирование
- Меньший эффект по сравнению с кэшированием

**Ожидаемый эффект:** Сокращение времени поиска на 30-50%

**Реализация:**
```csharp
// Порядок поиска:
// 1. Директория текущего проекта
// 2. Директория решения
// 3. Родительские директории (от ближайшей к дальней)
// 4. Директория analysis (если она есть)
```

---

### Вариант 4: Комбинированный подход (Рекомендуемый)

**Описание:** Сочетание кэширования директорий и оптимизации порядка поиска.

**Преимущества:**
- Максимальный эффект от оптимизации
- Баланс между производительностью и сложностью
- Масштабируемость

**Недостатки:**
- Более сложная реализация
- Требует тщательного тестирования

**Ожидаемый эффект:** Сокращение общего времени работы на 80-90%

**Архитектура:**
```
┌─────────────────────────────────────────┐
│         ProjectIndexService              │
│  ┌───────────────────────────────────┐  │
│  │  DirectoryCache                   │  │
│  │  - Кэш списков файлов по директориям │  │
│  └───────────────────────────────────┘  │
│  ┌───────────────────────────────────┐  │
│  │  ProjectNameIndex                 │  │
│  │  - Индекс имя проекта → путь      │  │
│  └───────────────────────────────────┘  │
└─────────────────────────────────────────┘
           ↓
┌─────────────────────────────────────────┐
│         SolutionService                  │
│  - FindProjectFileInFileSystem          │
│  - ResolveProjectPath                   │
└─────────────────────────────────────────┘
```

---

### Вариант 5: Параллельный поиск в директориях

**Описание:** Использовать параллельный поиск в нескольких директориях одновременно.

**Преимущества:**
- Ускорение на многоядерных системах
- Не требует изменения логики поиска

**Недостатки:**
- Увеличение нагрузки на диск
- Сложность синхронизации
- Может не дать эффекта на HDD

**Ожидаемый эффект:** Сокращение времени поиска на 40-60% на SSD

**Реализация:**
```csharp
private string FindProjectFileInFileSystemParallel(string projectName, List<string> directories)
{
    var results = new ConcurrentBag<string>();
    
    Parallel.ForEach(directories, dir =>
    {
        var found = SearchDirectory(projectName, dir);
        if (found != null)
            results.Add(found);
    });
    
    return results.FirstOrDefault();
}
```

---

## Рекомендации

### Краткосрочные решения (быстрая реализация)

1. **Вариант 1 (Кэширование директорий)** - можно реализовать за 1-2 часа
2. **Вариант 3 (Оптимизация порядка поиска)** - можно реализовать за 30 минут

### Долгосрочные решения (максимальный эффект)

1. **Вариант 4 (Комбинированный подход)** - оптимальное решение для продакшена
2. **Вариант 2 (Индексирование)** - если нужно максимальная производительность

### План реализации

#### Этап 1: Быстрые победы
- Реализовать кэширование директорий (Вариант 1)
- Оптимизировать порядок поиска (Вариант 3)

#### Этап 2: Глубокая оптимизация
- Создать индекс проектов (Вариант 2)
- Интегрировать с существующим кодом

#### Этап 3: Тестирование и настройка
- Протестировать на реальных проектах
- Настроить параметры кэша
- Очистить код и документацию

---

## Метрики для оценки

До оптимизации:
- Общее время обработки: ~5-10 минут
- Поиск одного проекта: 1-5 секунд
- Сканирование директории analysis: 1-4.5 секунды

После оптимизации (ожидаемые значения):
- Общее время обработки: ~30-60 секунд
- Поиск одного проекта: <100 мс (с индексом) или <500 мс (с кэшем)
- Сканирование директории analysis: <100 мс (с кэшем)